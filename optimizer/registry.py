#!/usr/bin/env python3
"""
Skills Registry: Manage Golden Examples with GitHub PR workflow.

Enables team-based skill compounding through PR-based review:
1. Register new examples from retrospective
2. Create PRs for team review
3. Sync merged skills back to local
"""

import argparse
import json
import subprocess
from pathlib import Path
from datetime import datetime
from typing import List, Optional, Dict


# Registry index file
REGISTRY_INDEX = ".skills_registry.json"


def load_registry(repo_root: Path) -> Dict:
    """Load the registry index from disk."""
    index_path = repo_root / REGISTRY_INDEX
    if index_path.exists():
        return json.loads(index_path.read_text())
    return {"examples": [], "pending_prs": [], "last_sync": None}


def save_registry(repo_root: Path, registry: Dict) -> None:
    """Save the registry index to disk."""
    index_path = repo_root / REGISTRY_INDEX
    index_path.write_text(json.dumps(registry, indent=2))


def register_example(
    example_path: Path,
    repo_root: Path,
    domain: Optional[str] = None
) -> bool:
    """
    Register a new example in the local registry.
    
    Args:
        example_path: Path to the .example.md file
        repo_root: Repository root
        domain: Optional domain override (auto-detected from path)
    """
    if not example_path.exists():
        print(f"[ERROR] Example not found: {example_path}")
        return False
    
    # Auto-detect domain from path
    if domain is None:
        parts = example_path.parts
        if "examples" in parts:
            idx = parts.index("examples")
            if idx + 1 < len(parts):
                domain = parts[idx + 1]
    
    registry = load_registry(repo_root)
    
    example_entry = {
        "path": str(example_path.relative_to(repo_root)),
        "domain": domain or "unknown",
        "registered_at": datetime.utcnow().isoformat(),
        "pr_created": False,
        "pr_url": None,
        "merged": False
    }
    
    # Check if already registered
    existing_paths = [e["path"] for e in registry["examples"]]
    if example_entry["path"] in existing_paths:
        print(f"[INFO] Example already registered: {example_entry['path']}")
        return True
    
    registry["examples"].append(example_entry)
    save_registry(repo_root, registry)
    
    print(f"[SUCCESS] Registered: {example_entry['path']} (domain: {domain})")
    return True


def create_pr(
    example_path: Path,
    repo_root: Path,
    dry_run: bool = False
) -> Optional[str]:
    """
    Create a GitHub PR for a new skill example.
    
    Returns the PR URL if successful, None otherwise.
    """
    rel_path = example_path.relative_to(repo_root)
    example_id = example_path.stem.replace("_golden.example", "").replace(".example", "")
    branch_name = f"skill/{example_id}"
    
    # Read example for PR body
    content = example_path.read_text()
    problem_match = content.split("## Problem")[1].split("## Solution")[0] if "## Problem" in content else ""
    problem_preview = problem_match[:300].strip() if problem_match else "New skill example"
    
    commands = [
        f"git checkout -b {branch_name}",
        f"git add {rel_path}",
        f'git commit -m "feat(skills): Add {example_id} example"',
        f"git push -u origin {branch_name}",
        f'gh pr create --title "feat(skills): Add {example_id} Golden Example" --body "## New Skill\\n\\n{problem_preview}\\n\\n---\\nAuto-generated by Skills Registry"'
    ]
    
    if dry_run:
        print(f"\n[DRY-RUN] Would execute:")
        for cmd in commands:
            print(f"  $ {cmd}")
        return "https://github.com/example/repo/pull/0"
    
    try:
        for cmd in commands:
            print(f"[EXEC] {cmd}")
            result = subprocess.run(
                cmd,
                shell=True,
                cwd=repo_root,
                capture_output=True,
                text=True
            )
            if result.returncode != 0:
                print(f"[ERROR] Command failed: {result.stderr}")
                return None
        
        # Parse PR URL from gh output
        pr_url = result.stdout.strip()
        
        # Update registry
        registry = load_registry(repo_root)
        for entry in registry["examples"]:
            if entry["path"] == str(rel_path):
                entry["pr_created"] = True
                entry["pr_url"] = pr_url
        save_registry(repo_root, registry)
        
        print(f"[SUCCESS] PR created: {pr_url}")
        return pr_url
        
    except Exception as e:
        print(f"[ERROR] Failed to create PR: {e}")
        return None


def list_pending(repo_root: Path) -> List[Dict]:
    """List examples pending review (PR created but not merged)."""
    registry = load_registry(repo_root)
    pending = [
        e for e in registry["examples"]
        if e.get("pr_created") and not e.get("merged")
    ]
    return pending


def list_unregistered(repo_root: Path) -> List[Path]:
    """Find examples not yet in registry."""
    registry = load_registry(repo_root)
    registered_paths = set(e["path"] for e in registry["examples"])
    
    examples_dir = repo_root / "examples"
    unregistered = []
    
    for example_file in examples_dir.rglob("*.example.md"):
        rel_path = str(example_file.relative_to(repo_root))
        if rel_path not in registered_paths:
            unregistered.append(example_file)
    
    return unregistered


def sync_registry(repo_root: Path, dry_run: bool = False) -> int:
    """
    Sync registry with merged PRs.
    Marks examples as merged if their PRs are closed.
    
    Returns count of newly synced examples.
    """
    registry = load_registry(repo_root)
    synced = 0
    
    for entry in registry["examples"]:
        if entry.get("pr_created") and not entry.get("merged") and entry.get("pr_url"):
            # Check PR status via gh cli
            pr_url = entry["pr_url"]
            try:
                result = subprocess.run(
                    f"gh pr view {pr_url} --json state",
                    shell=True,
                    cwd=repo_root,
                    capture_output=True,
                    text=True
                )
                if result.returncode == 0:
                    state_info = json.loads(result.stdout)
                    if state_info.get("state") == "MERGED":
                        if not dry_run:
                            entry["merged"] = True
                        print(f"[SYNCED] {entry['path']} (merged)")
                        synced += 1
            except Exception as e:
                print(f"[WARN] Could not check PR status: {e}")
    
    if not dry_run:
        registry["last_sync"] = datetime.utcnow().isoformat()
        save_registry(repo_root, registry)
    
    print(f"\n[SUMMARY] Synced {synced} merged examples")
    return synced


def main():
    parser = argparse.ArgumentParser(description="Skills Registry CLI")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")
    
    # register command
    register_parser = subparsers.add_parser("register", help="Register a new example")
    register_parser.add_argument("path", type=Path, help="Path to .example.md file")
    register_parser.add_argument("--domain", type=str, help="Override domain")
    
    # pr command
    pr_parser = subparsers.add_parser("pr", help="Create PR for example(s)")
    pr_parser.add_argument("--path", type=Path, help="Specific example path")
    pr_parser.add_argument("--all", action="store_true", help="Create PRs for all unsubmitted")
    pr_parser.add_argument("--dry-run", action="store_true", help="Show commands without executing")
    
    # list command
    list_parser = subparsers.add_parser("list", help="List registry entries")
    list_parser.add_argument("--pending", action="store_true", help="Show only pending PRs")
    list_parser.add_argument("--unregistered", action="store_true", help="Show unregistered examples")
    
    # sync command
    sync_parser = subparsers.add_parser("sync", help="Sync with merged PRs")
    sync_parser.add_argument("--dry-run", action="store_true", help="Show what would be synced")
    
    args = parser.parse_args()
    
    # Detect repo root
    repo_root = Path.cwd()
    while repo_root != repo_root.parent:
        if (repo_root / ".git").exists():
            break
        repo_root = repo_root.parent
    
    if args.command == "register":
        register_example(args.path.resolve(), repo_root, args.domain)
    
    elif args.command == "pr":
        if args.all:
            registry = load_registry(repo_root)
            for entry in registry["examples"]:
                if not entry.get("pr_created"):
                    example_path = repo_root / entry["path"]
                    create_pr(example_path, repo_root, args.dry_run)
        elif args.path:
            create_pr(args.path.resolve(), repo_root, args.dry_run)
        else:
            print("[ERROR] Specify --path or --all")
    
    elif args.command == "list":
        if args.pending:
            pending = list_pending(repo_root)
            print(f"\n[PENDING PRs] {len(pending)} examples:")
            for e in pending:
                print(f"  - {e['path']} | {e.get('pr_url', 'No URL')}")
        elif args.unregistered:
            unregistered = list_unregistered(repo_root)
            print(f"\n[UNREGISTERED] {len(unregistered)} examples:")
            for p in unregistered:
                print(f"  - {p}")
        else:
            registry = load_registry(repo_root)
            print(f"\n[REGISTRY] {len(registry['examples'])} examples:")
            for e in registry["examples"]:
                status = "✓" if e.get("merged") else ("⏳" if e.get("pr_created") else "○")
                print(f"  {status} {e['path']} ({e['domain']})")
    
    elif args.command == "sync":
        sync_registry(repo_root, args.dry_run)
    
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
