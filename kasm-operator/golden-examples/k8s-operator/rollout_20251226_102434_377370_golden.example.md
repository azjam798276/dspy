---
id: "rollout_20251226_102434_377370_golden"
generated_at: "2026-01-02T16:24:01.904853"
tags: ["k8s-operator", "auto-generated"]
---

## Problem
---
id: "20251226_kubernetes_deployment"
difficulty: "hard"
tags: ["devops", "kubernetes", "helm", "deployment"]
tech_stack: "Kubernetes, Helm, Node.js, nginx"
---

# User Story
As a DevOps engineer, I want to create Kubernetes deployment manifests with proper health checks and resource limits.

# Context & Constraints
Deploy Node.js application to Kubernetes:

**Components:**
- Deployment with rolling update strategy
- Service with ClusterIP
- Ingress with TLS termination
- ConfigMap and Secrets
- HorizontalPodAutoscaler

**Requirements:**
- Liveness and readiness probes
- Resource requests and limits
- Pod disruption budget
- Rolling update with zero downtime
- Environment-specific configurations

**Technical Constraints:**
- Use Helm for templating
- Support multiple environments (dev, 

## Solution
{
  "session_id": "6f99a9ec-f4c8-4666-95fb-d9641048e59f",
  "response": "```json\n{\n  \"reasoning\": \"I have designed a comprehensive Helm chart for the Node.js application to meet all specified requirements. \\n\\n1.  **Architecture**: The chart includes a Deployment, Service, Ingress, HPA, PDB, and ServiceAccount. It uses a standard directory structure.\\n2.  **Deployment**: Configured with `RollingUpdate` strategy for zero-downtime deployments. It includes `livenessProbe` and `readinessProbe` pointing to `/health` (as per the Dockerfile example). Security contexts are set to run as non-root (user 1001) and drop capabilities, adhering to security best practices. Prometheus annotations are added to the pod template.\\n3.  **Configuration**: `values.yaml` provides sensible defaults for production, including resource requests/limits, autoscaling enabled, and ingress TLS configuration. Environment-specific overrides can be applied via separate values files (e.g., `values-dev.yaml`).\\n4.  **Resilience**: A `PodDisruptionBudget` ensures availability during voluntary disruptions. `HorizontalPodAutoscaler` is configured to scale based on CPU utilization.\\n5.  **Secrets**: I included an `ExternalSecret` template (conditional on `externalSecret.enabled`) to integrate with external secret stores (like AWS Secrets Manager or HashiCorp Vault) via the External Secrets Operator, satisfying the constraint for external secrets.\",\n  \"code_patch\": \"# path: examples/devops/charts/node-app/Chart.yaml\\napiVersion: v2\\nname: node-app\\ndescription: A Helm chart for Node.js application with high availability and security defaults\\ntype: application\\nversion: 0.1.0\\nappVersion: \\\"1.0.0\\\"\\n\\n# path: examples/devops/charts/node-app/values.yaml\\n# Default values for node-app.\\n\\nreplicaCount: 2\\n\\nimage:\\n  repository: my-node-app\\n  pullPolicy: IfNotPresent\\n  # Overrides the image tag whose default is the chart appVersion.\\n  tag: \\\"latest\\\"\\n\\nimagePullSecrets: []\\nnameOverride: \\\"\\\"\\nfullnameOverride: \\\"\\\"\\n\\nserviceAccount:\\n  create: true\\n  annotations: {}\\n  name: \\\"\\\"\\n\\npodAnnotations:\\n  prometheus.io/scrape: \\\"true\\\"\\n  prometheus.io/port: \\\"3000\\\"\\n  prometheus.io/path: \\\"/metrics\\\"\\n\\npodSecurityContext:\\n  fsGroup: 1001\\n\\nsecurityContext:\\n  capabilities:\\n    drop:\\n    - ALL\\n  readOnlyRootFilesystem: true\\n  runAsNonRoot: true\\n  runAsUser: 1001\\n\\nservice:\\n  type: ClusterIP\\n  port: 80\\n  targetPort: 3000\\n\\ningress:\\n  enabled: false\\n  className: \\\"nginx\\\"\\n  annotations:\\n    cert-manager.io/cluster-issuer: \\\"letsencrypt-prod\\\"\\n  hosts:\\n    - host: chart-example.local\\n      paths:\\n        - path: /\\n          pathType: ImplementationSpecific\\n  tls: []\\n  #  - secretName: chart-example-tls\\n  #    hosts:\\n  #      - chart-example.local\\n\\nresources:\\n  limits:\\n    cpu: 200m\\n    memory: 256Mi\\n  requests:\\n    cpu: 100m\\n    me

## Key Techniques
- JWT token handling
