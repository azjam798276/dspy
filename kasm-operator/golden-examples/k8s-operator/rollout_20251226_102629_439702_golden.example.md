---
id: "rollout_20251226_102629_439702_golden"
generated_at: "2026-01-02T16:24:01.930392"
tags: ["k8s-operator", "auto-generated"]
---

## Problem
---
id: "20251226_jwt_token_security"
difficulty: "hard"
tags: ["security", "jwt", "authentication", "token-management"]
tech_stack: "Node.js, Express, jsonwebtoken, Redis"
---

# User Story
As a security engineer, I want to implement secure JWT token management with proper expiration and revocation capabilities.

# Context & Constraints
Implement a dual-token authentication system:

**Token Structure:**
- Access Token: Short-lived (15 min), used for API calls
- Refresh Token: Long-lived (7 days), used to get new access tokens
- Store refresh tokens in Redis for revocation capability

**Security Requirements:**
- Use RS256 algorithm (asymmetric keys)
- Include minimal claims (sub, iat, exp, jti)
- Implement token blacklist in Redis for revoked tokens
- Rotate refresh tokens on each use (on

## Solution
{
  "session_id": "5d2e4513-25d0-4520-92ea-2df1c9be21b5",
  "response": "```json\n{\n  \"reasoning\": \"## Implementation Plan\\n\\n1. **Complexity Analysis:**\\n   - **Token Generation:** O(1) time/space using atomic Redis writes.\\n   - **Validation:** O(1) time using RS256 verification and O(1) Redis blacklist lookup.\\n   - **Revocation:** O(1) time for direct logout (deleting refresh token, blacklisting access token).\\n\\n2. **Security Strategy:**\\n   - **Dual-Token System:** Implemented short-lived Access Tokens (15m) and long-lived Refresh Tokens (7d) to balance security and UX.\\n   - **RS256:** Enforced asymmetric signing to protect the private key.\\n   - **Token Rotation:** Refresh tokens are single-use. Reusing an old token triggers failure, mitigating theft impact.\\n   - **Blacklisting:** Implemented immediate Access Token revocation on logout by caching the JTI in Redis until its natural expiry.\\n\\n3. **Edge Cases & Reliability:**\\n   - **Memory Management:** All Redis keys utilize `EX` (expiry) to prevent indefinite storage growth.\\n   - **Input Safety:** Checked token existence and type ('access' vs 'refresh') before processing.\\n   - **Reference Integrity:** Used explicitly imported dependencies and `process.env` for keys.\\n\\n## Tech Stack\\n- Node.js 18, Express\\n- `jsonwebtoken` (RS256)\\n- `redis` (Storage)\\n- `uuid` (Unique JTI generation)\",\n  \"code_changes\": [\n    {\n      \"path\": \"package.json\",\n      \"content\": \"{\\n  \\\"name\\\": \\\"secure-jwt-system\\\",\\n  \\\"version\\\": \\\"1.0.0\\\",\\n  \\\"scripts\\\": {\\n    \\\"test\\\": \\\"jest\\\"\\n  },\\n  \\\"dependencies\\\": {\\n    \\\"express\\\": \\\"^4.18.2\\\",\\n    \\\"jsonwebtoken\\\": \\\"^9.0.0\\\",\\n    \\\"redis\\\": \\\"^4.6.7\\\",\\n    \\\"uuid\\\": \\\"^9.0.0\\\",\\n    \\\"zod\\\": \\\"^3.21.4\\\"\\n  },\\n  \\\"devDependencies\\\": {\\n    \\\"jest\\\": \\\"^29.5.0\\\",\\n    \\\"supertest\\\": \\\"^6.3.3\\\",\\n    \\\"redis-mock\\\": \\\"^0.56.3\\\"\\n  }\\n}\"\n    },\n    {\n      \"path\": \"src/auth/tokenService.js\",\n      \"content\": \"const jwt = require('jsonwebtoken');\\nconst { v4: uuidv4 } = require('uuid');\\n\\n// Keys should be loaded from secure config/env\\nconst PRIVATE_KEY = process.env.JWT_PRIVATE_KEY;\\nconst PUBLIC_KEY = process.env.JWT_PUBLIC_KEY;\\n\\n// Redis Key Prefixes\\nconst REF_PREFIX = 'refresh:';\\nconst BL_PREFIX = 'blacklist:';\\n\\n/**\\n * Generates a pair of Access and Refresh tokens.\\n * Complexity: O(1)\\n */\\nasync function generateTokenPair(userId, redisClient) {\\n    const accessJti = uuidv4();\\n    const refreshJti = uuidv4();\\n\\n    // 1. Generate Access Token (15m)\\n    const accessToken = jwt.sign(\\n        { sub: userId, type: 'access', jti: accessJti },\\n        PRIVATE_KEY,\\n        { algorithm: 'RS256', expiresIn: '15m' }\\n    );\\n\\n    // 2. Generate Refresh Token (7d)\\n    const refreshToken = jwt.sign(\\n        { sub: userId, type: 'refresh', jti: refre

## Key Techniques
- async/await
- try/catch error handling
- JWT token handling
- Input validation
- Middleware pattern
