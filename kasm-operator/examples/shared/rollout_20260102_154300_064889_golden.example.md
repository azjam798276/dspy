---
id: "rollout_20260102_154300_064889_golden"
generated_at: "2026-01-02T16:03:02.800494"
tags: ["shared", "auto-generated"]
---

## Problem
---
id: "20260102_e2e_session_test"
difficulty: "hard"
tags: ["testing", "e2e", "kubectl", "webrtc", "browser"]
tech_stack: "Bash, kubectl, Playwright, WebRTC"
---

# User Story
As a QA engineer, I want end-to-end tests that verify complete session flow from creation to WebRTC streaming, so I can validate the entire platform works.

# Context & Constraints
**E2E Test Flow:**
```
1. Create VDISession via kubectl
2. Wait for Running status
3. Extract session URL
4. Connect browser to URL
5. Verify WebRTC stream
6. Terminate session
7. Verify cleanup
```

**Test Script:**
```bash
#!/bin/bash
# Create session
kubectl apply -f - <<EOF
apiVersion: vdi.kasm.io/v1alpha1
kind: VDISession
metadata:
  name: e2e-test-session
spec:
  user: e2e@test.com
  template: ubuntu-desktop
EOF

# Wait for Running

## Solution
{
  "session_id": "434c1fe8-0520-4108-8edb-989cee8983d1",
  "response": "The objective is to implement an automated End-to-End (E2E) test suite for the Kasm VDI Operator. This suite will treat the system as a black box, verifying that a `VDISession` custom resource correctly provisions infrastructure and establishes a functional WebRTC stream.\n\n**Reasoning for Changes:**\n1.  **`e2e/run_e2e.sh` (Orchestration):** This script acts as the test runner. It handles the lifecycle of the Kubernetes resources (setup and teardown) and passes dynamic configuration (the session URL) to the test harness. Using `kubectl wait` ensures the test is deterministic and doesn't flake on race conditions during pod startup.\n2.  **`e2e/playwright.config.ts` (Configuration):** Configures Playwright for the specific needs of VDI testing, such as ignoring HTTPS errors (common in self-signed dev environments) and setting appropriate timeouts for video stream negotiation.\n3.  **`e2e/specs/session.spec.ts` (Validation):** Implements the \"User Story\" logic. It uses browser automation to perform the login and, crucially, verifies the WebRTC stream is active by checking that the `<video>` element's `currentTime` is advancing, which is a definitive proof of frame decoding.\n4.  **`e2e/package.json` (Dependencies):** Ensures the test environment is reproducible by defining the necessary dependencies (`@playwright/test`).\n\n```json\n{\n  \"reasoning\": \"Implementing a self-contained E2E test suite that orchestrates the VDISession lifecycle via kubectl and verifies the WebRTC data plane using Playwright. This fulfills the requirement to validate the complete session flow from creation to streaming.\",\n  \"changes\": [\n    {\n      \"file\": \"e2e/package.json\",\n      \"content\": \"{\\n  \\\"name\\\": \\\"vdi-e2e-tests\\\",\\n  \\\"version\\\": \\\"1.0.0\\\",\\n  \\\"scripts\\\": {\\n    \\\"test\\\": \\\"playwright test\\\"\\n  },\\n  \\\"devDependencies\\\": {\\n    \\\"@playwright/test\\\": \\\"^1.40.0\\\",\\n    \\\"typescript\\\": \\\"^5.3.0\\\",\\n    \\\"ts-node\\\": \\\"^10.9.0\\\"\\n  }\\n}\"\n    },\n    {\n      \"file\": \"e2e/playwright.config.ts\",\n      \"content\": \"import { defineConfig, devices } from '@playwright/test';\\n\\nexport default defineConfig({\\n  testDir: './specs',\\n  timeout: 60000,\\n  expect: {\\n    timeout: 10000\\n  },\\n  fullyParallel: true,\\n  forbidOnly: !!process.env.CI,\\n  retries: process.env.CI ? 2 : 0,\\n  workers: process.env.CI ? 1 : undefined,\\n  reporter: 'list',\\n  use: {\\n    ignoreHTTPSErrors: true,\\n    trace: 'on-first-retry',\\n    video: 'on-first-retry',\\n  },\\n  projects: [\\n    {\\n      name: 'chromium',\\n      use: { ...devices['Desktop Chrome'] },\\n    },\\n  ],\\n});\"\n    },\n    {\n      \"file\": \"e2e/specs/session.spec.ts\",\n      \"content\": \"import { test, expect } from '@playwright/test';\\n\\ntest('WebRTC stream connects and receives frames', async ({ page }) => {\\n  const sessi

## Key Techniques
- async/await
- JWT token handling
- Input validation
